本科是软件工程专业，研究生也是软件工程专业主要研究三维片上网络映射算法，通过智能优化算法+贪心算法解决片上网络映射问题。15年毕业有7年软件开发经验，刚毕业去了软通做java开发，从数据建模到前端页面展示全栈开发，后因项目结束调岗位而且和离女朋友住的地方太远，而且离职，去了一家小公司，做java后台开发，后因公司业务量减少，多个月发不出工资而去了当前公司，做了3年半，当前在数字主线管理平台，平台基于将数据从采购、设计、制造、销售、运输、维护、产品部件追溯、产品质量追溯、到后续决策分析，整条链的数据打通的目的而设立，主要解决数据抽取、数据建模、数据整合、应用数据建模和开发等一系列问题，我在这个项目主要做需求分析、功能拆解、模型设计、数据抽取、宽表设计、存储过程开发、SQL优化、API开发与维护，主要做了千亿数据（上百TB）的质量追溯场景开发、百亿数据的器件上量监控场景开发、维护十亿级数据的供应风险分析场景、亿级数据的条码发货追溯场景开发，总共开发和维护数百个API，性能均能满足业务需求，为用户决策提供可靠数据支撑。

岗位能力：
1 需求分析：能够快速的理解用户所提出的需求，并且能够把需求有效转换成软件需求的基础要求，用户在找数据时，可以根据表里数据分析，用户提供表数据是否满足业务需求，比如表里只有产品线ID，但是历史场景里用的都是产品线编码，则需要通过从历史用表分析产品线ID和产品线编码的原始对于关系表，需要在后续宽表设计中增加此映射关系；从业务给的页面设计中，提出合理化的建议，比如针对树形展开的数据，业务需要根据值进行过滤，但是这个过滤的值即代表汇总行的数据，又代表明细数据的过滤，显然是不合理的。
2 功能拆解：能将快速理解业务语言，将业务需求拆解成IT需求，划清前后端的责任分工（有时候有些功能并不需要都由后台提供，比如全量数据是汇总后的数据，只有几百行，由后端查询后再做过滤性能会比较低，但是由前端回去全量数据后再过滤，只需要取一次数据，提升了交互体验）
3 模型设计：业务提供的表数据经常是包含了全量历史数据的表，并且表数据的值经常都是只有ID或者只有Name，那么需要从多张事实表中抽取数据到整合层，并且对原始表数据进行清理，使得表数据准确性更高，减少非必要数据，提升最终维表数据的轻量化
4 数据抽取：从数据湖或源系统，通过XDATA\FDI\ADMS\DataStage\建立外表的方式抽取数据，通过LTS\CTM工具实现任务的调度，完成千亿数据的抽取，并且通过Oracle表影子表方案（也就是建立分区表，通过交互分区数据，实现生产用表和临时表数据的无缝切换）
5 宽表设计：针对高斯库分布式和可以建立列存表的优势，将业务在各种事实表的数据整合到一张表，使得表数据量降低，但是字段增多，比如十几个月的发货数据和上板数据，加上汇总和求占比的数据需求，宽表字段大上百个，但是减少了数据行数，以及行列转换的资源消耗，使得查询从几秒钟降低到几百毫秒。列存表优势在于对宽表的查询和少量字段的聚合操作性能较好
6 存储过程开发：宽表设计好后，需要通过存储过程，整合各个事实表的数据，动态建立分区，针对一张大表数据全量去重后写入另外一张表，由于其实分区表，因此可以通过写循环语句，按分区去重后写入目标表
7 SQL性能优化：比如：条码中有编码信息，但是编码并不是在最左边，需要掐头去尾，但是用全模糊匹配不走索引，后改成先从条码中解析出编码，再给编码建索引，使得业务查询从分钟级降到秒级；
8 API开发与维护：三年期间开发数百个API，针对API都进行归档，保留各种测试联调数据，问题定位分析方法，因此即便历史接口的重新对接或者任务交接都可以快速完成。并且对API性能进行优化：比如最开始前端导出树形结构的数据，调用方式跟前端点击汇总行展开明细行一样，导致有多层，并且顶层有数前行的情况，调用接口次数达到数十万次，对后台数据块压力非常大，而且大量时间都浪费在发起接口请求，后将树形结构的导出，改成API直接返回树形结构数据，将接口调用次数降低到几十次，导出功能从小时级，降低到分钟级；

劣势：开发追求最少的返工，因此在前期分析阶段会花费较多时间，看上去前期产出较慢
优势：1）从底层数据到最终API开发有全套数据开发经验，有丰富的性能优化经验；2）既能做java开发，也能做数据开发；3）了解组内成员的技能栈，懂得根据成员的优势分配任务，善于任务的合理安排、进度跟踪、问题定位分析；4）心细，通常帮其他同事解决问题时，能够很快发现细节上的疏忽引发的问题；

职业规划
目前主要做数据抽取到服务开发一整条链，希望后续对这块的研究更加深入，对于大数据数据的处理，数据挖掘这块都比较感兴趣，并且也有看相关的一些资料

遇到的最大困难
在接手别人的工作时，因为该场景历史较为久远，业务需求文档几乎未零，涉及技术较多，包括DataStage任务、CTM调度、BIDS服务、Gox插件开发，刚接手时遇到测试时发现数据有问题，最后通过与之前参与过相关工作的人沟通，确认本地部署的方案，从前端接口调用开始，到底层数据来源分析，找到定位到时因为某张测试表的数据结构变动导致的异常，最后通过修改数据抽取的任务

关系型数据块的优化
1 通过查看执行计划，重新设计索引、强制使用索引、高斯库的数据分布到多个DN，当DN上的数据越均衡，数据查询性能越好，因此通过有针对性地调整分布键的方式提升性能；
2 原始数据为宽表，达上百个字段，而且数据量较大，原始表在Oracle时，查询很慢，后将数据抽取到高斯库，改成列存表，增加必要的索引，将性能从十几秒，提升到几百毫秒；
3 针对查出的结果数据量较大的情况，又需要分页返回所有数据，通过先根据查询条件，得到分页的ID，再根据ID查找其他明细字段，将查询性能从十几秒级，提升至秒级；
4 尽量少用delete删除数据，因为当delete多了后，表的数据块处于高水位，因为需要定期整理表数据，例如备份数据后，truncate表，再将数据写回；

图数据库的优化
1 分析执行计划，针对有索引但是不走索引的情况，强制使用索引；
2 将业务场景设计很多模型项关联，并且起始过滤条件涉及几十万的明细数据，可以将大图拆成小图，逐步解决小图的查询后，汇总出业务需求的数据；
3 针对很多历史数据，但是业务只需要最新版本数据的情况，而且此模型经常作为查询条件的起始模型，可以将模型抽取出最新版本数据，单独建模；
4 对于单模型几十万明细数据的汇总操作，Neo4j不适合此类查询，建议改成关系型数据库；


1 索引和表在物理磁盘上是分开存储的，可以存放到不同的表空间（最好也是）
2 表上的索引是独立存储的
3 索引的存放数据是有序的，数据块直接用指针关联，表数据的存放是无序的
4 索引的叶子节点存有rowid，通过rowid指向表数据
5 索引的所有叶子节点都在同一层
6 在表中一个数据块（8K）能放多少数据？在索引中，一个数据块能放多少数据？
7 索引的层高一般是 总数据量 除以 每个数据块可以存放数据条数的N次方，N就是层高，因此不要选择类似“描述”的多字节的字段建索引
8 如果数据被delete，数据占用的数据块并不会被释放，这就是所谓的高水位，当有新数据insert时，会优先使用空闲数据块
9 索引中不包含空的键值，但并不表示建索引的字段必须为非空，只是查空数据时，会走全表扫描
10 唯一索引，每个键值最多占一个叶子块，如果索引列的重复数据很多，那么一个键值可能占多个叶子块
11 索引的高度决定从根到叶子要查几个索引块，键值的重复度，决定了要查多少个叶子块，一个是纵向，一个是横向
12 IO/CPU/NETWORK 逻辑读、物理读，数据在索引上性能最快，常用数据逻辑读性能也快
13 多块读（全表扫描，也是可能比走索引更快的原因）、随机读、顺序读
14 将数据先写入redo文件后，再写入数据文件，可以控制数据位置是顺序写入的，最终实现顺序读
15 全表扫描：需要访问超过5%的数据总量，后台业务
16 索引唯一扫描：优先使用
17 索引范围扫描：适合命中少量数据的场景，不超过5%
18 索引全扫描：一般不建议使用，除非是大表排序后返回Top N 
19 索引快速扫描：只需要访问索引，不需要访问表
20 分区表不要创建全局索引,使用Local关键字创建本地索引
21 不要创建同样功能的索引
22 索引key不宜过长
23 组合索引，要把高选择读的列放前面
24 需要对大量数据排序时，通过创建索引来避免排序
25 需要创建必要的函数索引
